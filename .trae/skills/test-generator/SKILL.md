---
name: "test-generator"
description: "智能分析代码并生成高质量测试用例，自动识别需要测试的核心功能，避免无意义测试。当用户需要为代码编写测试用例时调用。"
---

# 智能测试用例生成器

## 功能概述

本skill通过智能分析TypeScript代码，识别真正需要测试的核心功能，避免生成无意义的测试用例，专注于业务逻辑和纯函数的测试覆盖。

## 使用场景

- 当用户说"为这个文件生成测试用例"或"帮我写测试"
- 当用户需要为新功能添加测试覆盖时
- 当用户想要提高代码测试质量时
- 当用户抱怨现有测试用例太多或无意义时

## 工作流程

### 1. 智能代码分析阶段

系统会：
- 解析AST提取所有函数和方法
- 计算代码复杂度评分（1-10分）
- 识别函数类型（纯函数、业务逻辑、工具函数等）
- 判断测试优先级（必须测试/建议测试/无需测试）

**测试优先级分类标准：**

🔴 **必须测试** (复杂度 ≥ 7 或包含以下特征):
- 条件判断语句 (if/else, switch)
- 循环语句 (for, while)
- 异常处理 (try/catch)
- 异步操作 (Promise, async/await)
- 数据转换和计算逻辑
- 业务规则验证

🟡 **建议测试** (复杂度 4-6 或包含以下特征):
- 参数验证和边界检查
- 简单的数据格式化
- 配置解析和处理
- 工具函数封装

🟢 **无需测试** (复杂度 ≤ 3 或包含以下特征):
- 纯console输出
- 简单的getter/setter
- 常量定义和导出
- 第三方库的直接调用
- 简单的对象属性访问

### 2. 用户交互确认阶段

展示分析结果，让用户选择需要测试的功能：

```
## 代码分析结果

文件: src/utils/calculator.ts
发现 5 个函数，其中 3 个建议测试

🔴 必须测试 (高复杂度业务逻辑):
  1. calculateTotalPrice() - 复杂度: 8/10
     └─ 包含折扣计算、税费处理、边界检查

🟡 建议测试 (中等复杂度):
  2. validateDiscountCode() - 复杂度: 5/10
     └─ 优惠券格式验证和过期检查
  3. formatCurrency() - 复杂度: 4/10  
     └─ 货币格式化显示

🟢 无需测试 (简单函数):
  - printReceipt() - 仅输出收据信息
  - getDefaultTaxRate() - 简单返回默认值

请选择要测试的功能 (输入序号，多个用逗号分隔，或输入 'all' 测试所有推荐):
```

### 3. 测试用例生成阶段

根据用户选择，生成原子化的测试用例：

**原子化设计原则：**
- 每个测试用例只验证一个行为
- 包含正向测试、边界测试、异常测试
- 使用描述性的测试名称
- 包含必要的mock和setup

**生成的测试结构：**
```typescript
describe('calculateTotalPrice', () => {
  it('应该正确计算无折扣的基础价格', () => {
    // 测试基础计算逻辑
  });

  it('应该正确应用百分比折扣', () => {
    // 测试折扣计算
  });

  it('应该处理折扣码无效的情况', () => {
    // 测试无效折扣码处理
  });

  it('应该正确计算税费', () => {
    // 测试税费计算
  });

  it('应该处理负价格等边界条件', () => {
    // 测试边界条件
  });
});
```

### 4. 测试验证阶段

生成测试用例后：
- 自动运行测试验证正确性
- 根据错误信息调整测试用例或业务代码
- 确保测试通过率达到要求

## 代码实现规范

### 测试文件命名
- 测试文件：`index.test.ts`
- 存放位置：同级目录下的`__tests__`文件夹

### 测试代码规范
- 使用Vitest测试框架
- 遵循AAA模式（Arrange, Act, Assert）
- 测试名称使用"应该..."格式
- 包含适当的注释说明

### 控制台输出处理
对于需要在测试中屏蔽的console输出：
```typescript
if (process.env.VITEST) {
  // 测试环境下需要执行的代码
}
```

## 质量保障

1. **智能过滤**：自动识别并跳过无需测试的代码
2. **复杂度评估**：基于代码复杂度确定测试优先级
3. **用户确认**：让用户选择真正需要测试的功能
4. **原子化设计**：每个测试用例专注验证一个行为
5. **自动验证**：生成后自动运行测试确保正确性

## 使用示例

用户："帮我为analyse.ts生成测试用例"

系统：
1. 分析代码结构和复杂度
2. 识别出`analyzeProject()`等核心函数
3. 展示分析结果供用户选择
4. 生成原子化测试用例
5. 运行测试验证正确性

这样可以确保生成的测试用例都是有价值、有意义的高质量测试。